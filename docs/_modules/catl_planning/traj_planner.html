<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>catl_planning.traj_planner &mdash; IITCHS Base  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> IITCHS Base
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">IITCHS Base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scenarios.html">Custom Scenarios</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../temporal_logic_primer.html">Temporal Logic Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks/index_benchmarks.html">Benchmarking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer_notes/index_developer_notes.html">Developer Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source_code_index.html">Source Code Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">IITCHS Base</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>catl_planning.traj_planner</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for catl_planning.traj_planner</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1">#--------------------------------------------------------------------------------</span>

<span class="c1">#LL Copyright</span>
<span class="c1">#This material is based upon work supported by the Under Secretary of Defense for Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any opinions, findings, conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the Under Secretary of Defense for Research and Engineering.</span>
<span class="c1">#Â© 2019 Massachusetts Institute of Technology.</span>
<span class="c1">#The software firmware is provided to you on an As-Is basis</span>
<span class="c1">#Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part 252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government rights in this work are defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed above. Use of this work other than as specifically authorized by the U.S. Government may violate any copyrights that exist in this work.</span>
<span class="c1">#LL Copyright</span>

<span class="c1">#--------------------------------------------------------------------------------</span>

<span class="c1"># DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.</span>

<span class="c1"># This material is based upon work supported by the Under Secretary of Defense for </span>
<span class="c1"># Research and Engineering under Air Force Contract No. FA8702-15-D-0001. Any </span>
<span class="c1"># opinions, findings, conclusions or recommendations expressed in this material </span>
<span class="c1"># are those of the author(s) and do not necessarily reflect the views of the Under </span>
<span class="c1"># Secretary of Defense for Research and Engineering.</span>

<span class="c1"># (C) 2021 Massachusetts Institute of Technology.</span>

<span class="c1"># Subject to FAR52.227-11 Patent Rights - Ownership by the contractor (May 2014)</span>

<span class="c1"># The software/firmware is provided to you on an As-Is basis</span>

<span class="c1"># Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS </span>
<span class="c1"># Part 252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. </span>
<span class="c1"># Government rights in this work are defined by DFARS 252.227-7013 or DFARS </span>
<span class="c1"># 252.227-7014 as detailed above. Use of this work other than as specifically </span>
<span class="c1"># authorized by the U.S. Government may violate any copyrights that exist in this </span>
<span class="c1"># work.</span>

<span class="c1"># SPDX-License-Identifier: BSD-3-Clause</span>

<span class="c1">#--------------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">lomap</span> <span class="kn">import</span> <span class="n">Ts</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">catl_planning.reduced_ts</span> <span class="kn">import</span> <span class="n">ReducedTs</span>
<span class="kn">from</span> <span class="nn">catl_planning.route_planning</span> <span class="kn">import</span> <span class="n">compute_agent_classes</span><span class="p">,</span> <span class="n">compute_capability_bitmap</span>
<span class="kn">from</span> <span class="nn">catl_planning.rrt_planning</span> <span class="kn">import</span> <span class="n">RRT_Get_Path</span>
<span class="kn">from</span> <span class="nn">catl_planning.utils</span> <span class="kn">import</span> <span class="n">state2int</span><span class="p">,</span> <span class="n">int2state</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pdb</span>

<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">shapely.geometry.polygon</span> <span class="kn">import</span> <span class="n">Polygon</span>


<span class="c1">#FOR VIDEO - Uncomment two lines below</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;TkAgg&quot;</span><span class="p">)</span>
<span class="c1"># from matplotlib.animation import FFMpegWriter</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">catl_planning.visualization</span> <span class="kn">import</span> <span class="n">show_environment_agents</span>
<span class="kn">from</span> <span class="nn">catl_planning.visualization</span> <span class="kn">import</span> <span class="n">show_transition_agents</span>
<span class="kn">from</span> <span class="nn">catl_planning.visualization</span> <span class="kn">import</span> <span class="n">show_world</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">timer</span>

<span class="c1">###############################################################################</span>
<span class="c1">#Parse Data from sol file</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="read_sol_data"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.read_sol_data">[docs]</a><span class="k">def</span> <span class="nf">read_sol_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">ts</span><span class="p">):</span>
    <span class="c1">#This is the data file to parse - designed for gurobi.sol files</span>
    <span class="c1">#data = pd.read_csv(&quot;isrr2019.sol&quot;,sep=&#39;\n&#39;)</span>
    <span class="c1"># Format of the `states` variable:</span>
    <span class="c1">#   column 1:   State number</span>
    <span class="c1">#   column 2:   Timestep</span>
    <span class="c1">#   column 3:   Capability number</span>
    <span class="c1">#   column 4:   Number of agents in the state with that capability at that timestep</span>
    <span class="c1">#</span>
    <span class="c1"># **The states matrix only records information for states and timesteps with nonzero column 4 entries.**</span>
    <span class="c1"># It essentially tracks all timesteps and states that have nonzero capabilities in that state.  </span>
    
    <span class="n">var_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># obstacleList[0] - Ground obstacles</span>
    <span class="c1"># obstacleList[1] - Mid-air obstacles</span>
    <span class="c1"># obstacleList[2] - top-Air obstacles</span>

    <span class="c1">#temp_edge_weights = nx.get_edge_attributes(ts.g,&#39;weight&#39;)</span>
    
    <span class="c1">#record last time </span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#record_max_weight</span>
    <span class="n">max_weight</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">#This loop extracts the states and edges from the solution and puts them into a numpy array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">var_data</span><span class="p">)):</span>

        <span class="k">if</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span> <span class="ow">and</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;q&#39;</span><span class="p">:</span>
            <span class="c1">#States</span>
            <span class="k">if</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">vars</span> <span class="o">=</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">time_state</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">time_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Change any &#39;n&#39; characters to a negative sign, due to PuLP naming conventions</span>
                <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>  <span class="o">+</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="n">num</span> <span class="o">=</span> <span class="n">time_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">state</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cap</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># DEBUG</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CHECK time VARIABLE&quot;</span><span class="p">)</span>
                <span class="c1"># \DEBUG</span>

                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">state</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cap</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">))])</span>
            <span class="c1">#Edges</span>
            <span class="k">if</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="nb">vars</span> <span class="o">=</span> <span class="n">var_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">time_state</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">time_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Change any &#39;n&#39; characters to a negative sign, due to PuLP naming conventions</span>
                <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>  <span class="o">+</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="n">num</span> <span class="o">=</span> <span class="n">time_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">state1</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">state2</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">cap</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;grave&#39;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">state1</span><span class="p">)][</span><span class="s1">&#39;prop&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;grave&#39;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">state2</span><span class="p">)][</span><span class="s1">&#39;prop&#39;</span><span class="p">]:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">state1</span><span class="p">)][</span><span class="s1">&#39;q&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">state2</span><span class="p">)][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="n">max_weight</span><span class="p">:</span>
                        <span class="n">max_weight</span> <span class="o">=</span> <span class="n">weight</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
                <span class="c1">#weight = temp_edge_weights[(&#39;q&#39;+str(state1),&#39;q&#39;+str(state2))]</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">state1</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">state2</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)),</span><span class="n">weight</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cap</span><span class="p">)),</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">))])</span>
                
    <span class="c1"># populate an array with p_vars</span>
    <span class="c1"># entries are label, predicate, time, state, count</span>
    <span class="n">p_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">var_data</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;p_&#39;</span><span class="p">]</span>
    <span class="c1"># preds = []</span>
    <span class="c1"># map(lambda x: preds.append([x.split(&#39;_&#39;)[1],x.split(&#39;_&#39;)[2],x.split(&#39;_&#39;)[3],x.split(&#39;_&#39;)[4].split(&#39; &#39;)[0],x.split(&#39;_&#39;)[4].split(&#39; &#39;)[1]]), p_vars)</span>
    <span class="n">preds</span> <span class="o">=</span>  <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">p_vars</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
    
    <span class="c1">#Make them numpy arrays</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="c1">#print(states)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time_params&#39;</span><span class="p">,</span><span class="n">end_time</span><span class="p">,</span><span class="n">max_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,(</span><span class="n">end_time</span><span class="o">+</span><span class="n">max_weight</span><span class="p">),</span><span class="n">preds</span></div>
    
    
<span class="c1">###############################################################################</span>
<span class="c1">#Check if point is in past trajectory obstacle</span>
<span class="c1">###############################################################################    </span>
<div class="viewcode-block" id="collision_check"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.collision_check">[docs]</a><span class="k">def</span> <span class="nf">collision_check</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">current_time</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">past_paths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">in_obs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">past_paths</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">past_obs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">past_paths</span><span class="p">)):</span>
            <span class="c1">#print(past_paths)</span>
            <span class="n">past_obs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">past_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">current_time</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">radius</span><span class="o">*</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">past_obs</span><span class="p">)):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">past_obs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">past_obs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)),</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">:</span>
                <span class="n">in_obs</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">in_obs</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Find bounds for planning between regions</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="split_bounds_for_rrt"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.split_bounds_for_rrt">[docs]</a><span class="k">def</span> <span class="nf">split_bounds_for_rrt</span><span class="p">(</span><span class="n">region1</span><span class="p">,</span><span class="n">region2</span><span class="p">,</span><span class="n">bounds</span><span class="p">,</span><span class="n">overlaps</span><span class="p">):</span>
    <span class="n">new_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">region</span> <span class="o">!=</span> <span class="n">region1</span> <span class="ow">and</span> <span class="n">region</span><span class="o">!=</span> <span class="n">region2</span> <span class="ow">and</span> <span class="n">region</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">region</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region2</span><span class="p">]:</span>
            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">set</span><span class="p">))</span>
    <span class="k">return</span><span class="p">(</span><span class="n">new_bounds</span><span class="p">)</span></div>

<span class="c1">###############################################################################</span>
<span class="c1">#Find bounds for planning between regions with box world</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="split_box_bounds_for_rrt"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.split_box_bounds_for_rrt">[docs]</a><span class="k">def</span> <span class="nf">split_box_bounds_for_rrt</span><span class="p">(</span><span class="n">region1</span><span class="p">,</span><span class="n">region2</span><span class="p">,</span><span class="n">box_bounds</span><span class="p">,</span><span class="n">overlaps</span><span class="p">):</span>
    <span class="n">new_box_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">box_bounds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">region</span> <span class="o">!=</span> <span class="n">region1</span> <span class="ow">and</span> <span class="n">region</span><span class="o">!=</span> <span class="n">region2</span> <span class="ow">and</span> <span class="n">region</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">region</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region2</span><span class="p">]:</span>
            <span class="n">new_box_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_box_bounds</span></div>

<span class="c1">###############################################################################</span>
<span class="c1">#Find bounds of single region</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="single_region_bounds_for_rrt"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.single_region_bounds_for_rrt">[docs]</a><span class="k">def</span> <span class="nf">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="n">bounds</span><span class="p">,</span><span class="n">overlaps</span><span class="p">):</span>
    <span class="n">new_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">regions</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">regions</span> <span class="o">!=</span> <span class="n">region</span> <span class="ow">and</span> <span class="n">regions</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region</span><span class="p">]:</span>
            <span class="n">new_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">set</span><span class="p">))</span>
    <span class="k">return</span><span class="p">(</span><span class="n">new_bounds</span><span class="p">)</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Find bounds of single region in box world</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="single_region_box_bounds_for_rrt"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.single_region_box_bounds_for_rrt">[docs]</a><span class="k">def</span> <span class="nf">single_region_box_bounds_for_rrt</span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="n">box_bounds</span><span class="p">,</span><span class="n">overlaps</span><span class="p">):</span>
    <span class="n">new_box_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">regions</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">box_bounds</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">regions</span> <span class="o">!=</span> <span class="n">region</span> <span class="ow">and</span> <span class="n">regions</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">overlaps</span><span class="p">[</span><span class="n">region</span><span class="p">]:</span>
            <span class="n">new_box_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">set</span><span class="p">))</span>
    <span class="k">return</span><span class="p">(</span><span class="n">new_box_bounds</span><span class="p">)</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Find a random point in a given region given past trajectories</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="random_point_in_region"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.random_point_in_region">[docs]</a><span class="k">def</span> <span class="nf">random_point_in_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">past_paths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">current_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="p">[],</span><span class="n">over_inc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">plot_region_bounds</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="n">radius</span><span class="o">+</span><span class="mf">.1</span><span class="p">,</span> <span class="mi">160</span><span class="o">-</span><span class="n">radius</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="n">radius</span><span class="o">+</span><span class="mf">.1</span><span class="p">,</span> <span class="mi">60</span><span class="o">-</span><span class="n">radius</span><span class="o">-</span><span class="mf">.1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">plot_region_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">+</span><span class="mf">.1</span><span class="p">,</span> <span class="n">plot_region_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">radius</span><span class="o">-</span><span class="mf">.1</span><span class="p">,</span> <span class="n">plot_region_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">+</span><span class="mf">.1</span><span class="p">,</span> <span class="n">plot_region_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">radius</span><span class="o">-</span><span class="mf">.1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_obstacles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">non_region_obstacles</span> <span class="o">=</span> <span class="n">other_obstacles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">non_region_obstacles</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">past_obs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">over_inc</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">past_paths</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">current_time</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">past_paths</span><span class="p">)):</span>
                <span class="n">past_obs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">past_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">current_time</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">radius</span><span class="p">]))</span>
            <span class="n">non_region_obstacles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">non_region_obstacles</span><span class="p">,</span><span class="n">past_obs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">past_paths</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">current_time</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">past_paths</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">over_inc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">current_time</span><span class="o">-</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1">#print current_time</span>
                        <span class="c1">#print y</span>
                        <span class="n">past_obs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">past_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">current_time</span><span class="o">-</span><span class="n">y</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">radius</span><span class="p">]))</span>
                    <span class="n">past_obs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">past_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">current_time</span><span class="o">+</span><span class="n">y</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">radius</span><span class="p">]))</span>
            <span class="n">non_region_obstacles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">non_region_obstacles</span><span class="p">,</span><span class="n">past_obs</span><span class="p">))</span>
    <span class="n">no_point</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">no_point</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="c1">#print(&#39;Point Stuck in Unforseen Obstacle - Please Try Again&#39;)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">randx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">region</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">randy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(),</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">region</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> <span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">in_obs</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">ox</span><span class="p">,</span><span class="n">oy</span><span class="p">,</span><span class="n">size</span> <span class="ow">in</span> <span class="n">non_region_obstacles</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">ox</span><span class="o">-</span><span class="n">randx</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">oy</span><span class="o">-</span><span class="n">randy</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">+</span><span class="n">radius</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">in_obs</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">in_obs</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">randx</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">randx</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">randy</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">randy</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                    <span class="n">no_point</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">no_point</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span>


    <span class="n">rand_point</span> <span class="o">=</span> <span class="p">[</span><span class="n">randx</span><span class="p">,</span><span class="n">randy</span><span class="p">]</span>
    <span class="c1">#print(non_region_obstacles,rand_point)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">rand_point</span><span class="p">)</span></div>




<span class="c1">###############################################################################</span>
<span class="c1">#Generate Individual Region Trajectories</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="assign_caps_to_trajs"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.assign_caps_to_trajs">[docs]</a><span class="k">def</span> <span class="nf">assign_caps_to_trajs</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">preds</span><span class="p">,</span><span class="n">sim_time</span><span class="p">,</span><span class="n">replan_agent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">grave_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">start_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">replan_agent_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">replanning_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1">#grave_state needs to be just an int</span>
    <span class="c1">#</span>
    <span class="c1"># Format of the `states` variable:</span>
    <span class="c1">#   column 1:   State number</span>
    <span class="c1">#   column 2:   Timestep</span>
    <span class="c1">#   column 3:   Capability number</span>
    <span class="c1">#   column 4:   Number of agents in the state with that capability at that timestep</span>
    <span class="c1">#</span>
    <span class="c1"># **The states matrix only records information for states and timesteps with nonzero column 4 entries.**</span>
    <span class="c1"># It essentially tracks all timesteps and states that have nonzero capabilities in that state.  </span>
    
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">sim_time</span>
    <span class="n">caps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">agent_caps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_caps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">caps</span><span class="p">))</span>
    <span class="n">cap_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">caps</span><span class="p">))</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">init_states</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">time_stamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1">#Count agents and capabilities</span>
    <span class="n">agent_caps</span><span class="p">,</span> <span class="n">num_caps</span> <span class="o">=</span> <span class="n">get_agent_capabilities</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="n">agent_caps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">agent_caps</span><span class="p">)</span>

    <span class="n">num_agents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_caps</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">agent_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">end_time</span><span class="p">,</span><span class="n">num_agents</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">transit_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end_time</span><span class="p">,</span><span class="n">num_agents</span><span class="p">))</span>

    <span class="c1"># initialize trajectory</span>
    <span class="c1"># NOTE: The initial row agent_positions[0] corresponds to MILP time step 0 when start_time = 0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">caps</span><span class="p">:</span>
        <span class="n">num_of_type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">choice_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">choice_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">past_num</span> <span class="o">=</span> <span class="n">num_of_type</span>
            <span class="n">num_of_type</span> <span class="o">=</span> <span class="n">num_of_type</span> <span class="o">+</span> <span class="n">init_states</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">region_of_type</span> <span class="o">=</span> <span class="n">init_states</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cap_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">agent_caps</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">past_num</span><span class="p">,</span><span class="n">num_of_type</span><span class="p">):</span>
                <span class="n">agent_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">cap_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">region_of_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

    <span class="n">edge_timer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_agents</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span><span class="n">sim_time</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

        <span class="n">current_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">t</span><span class="p">]</span>
        <span class="n">already_assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_agents</span><span class="p">)</span>
        <span class="c1">#Update Edge Timing</span>
        <span class="n">transit_times</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_timer</span>
        <span class="n">edge_timer</span> <span class="o">=</span> <span class="n">edge_timer</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">edge_timer</span><span class="p">[</span><span class="n">edge_timer</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#Prevent moving agents from being assigned</span>
        <span class="n">already_assigned</span><span class="p">[</span><span class="n">edge_timer</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Handle all of the failed agents.</span>
        <span class="c1"># This assigns them to the grave state and ensures they are unavailable</span>
        <span class="c1"># for assignment to other states / trajectories.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replan_agent_idx</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">replanning_time</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">replan_agent_idx</span><span class="p">)):</span>
                <span class="n">already_assigned</span><span class="p">[</span><span class="n">replan_agent_idx</span><span class="p">[</span><span class="n">dx</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">agent_current_state</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">replan_agent_idx</span><span class="p">[</span><span class="n">dx</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agent_current_state</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># The dead agent should be traversing the edge to the grave state.</span>
                    <span class="c1"># Have it arrive at the grave state at the next time step.</span>
                    <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">replan_agent_idx</span><span class="p">[</span><span class="n">dx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">grave_state</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">agent_current_state</span> <span class="o">!=</span> <span class="n">grave_state</span><span class="p">:</span>
                        <span class="c1"># Put the dead agent on the edge from its current state to the grave state.</span>
                        <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">replan_agent_idx</span><span class="p">[</span><span class="n">dx</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">agent_current_state</span><span class="p">,</span> <span class="n">grave_state</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># The agent is already in the grave state; have it continue there.</span>
                        <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">replan_agent_idx</span><span class="p">[</span><span class="n">dx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">grave_state</span>

        <span class="c1"># Handle all non-failed agents.</span>
        <span class="c1">#insert line where if edge_timer &gt; 0 with -1 then assigned</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">caps</span><span class="p">:</span>
            <span class="n">num_of_type</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">choice_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">current_edge</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">choice_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">eval_edge</span> <span class="o">=</span> <span class="n">current_edge</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
                <span class="c1"># Skip this edge if it&#39;s the edge connecting the grave state to itself.</span>
                <span class="c1"># The dead agents on this edge were already assigned there above.</span>
                <span class="k">if</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">grave_state</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">not_assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">already_assigned</span><span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">current_cap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">agent_caps</span><span class="o">==</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">not_assigned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">not_assigned</span><span class="p">,</span><span class="n">current_cap</span><span class="p">)</span>
                <span class="n">free_agents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">not_assigned</span><span class="p">]</span> <span class="o">==</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">available</span> <span class="o">=</span> <span class="n">not_assigned</span><span class="p">[</span><span class="n">free_agents</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">available</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">available</span><span class="p">)</span>

                <span class="c1"># TODO: Ignore the grave_state self-edges.</span>

                <span class="k">if</span> <span class="n">available</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
                    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">debug</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error time: &#39;</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;edge requested: &#39;</span><span class="p">,</span><span class="n">eval_edge</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;agent_positions: &#39;</span><span class="p">,</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;available:&#39;</span><span class="p">,</span><span class="n">available</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;available: &#39;</span><span class="p">,</span><span class="n">available</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="s1">&#39; asking for: &#39;</span><span class="p">,</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                    <span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Requested Agents Not Available&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">5</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="c1">#Agents stay in the same place</span>
                        <span class="n">already_assigned</span><span class="p">[</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">edge_timer</span><span class="p">[</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Agents enter edge</span>
                        <span class="n">already_assigned</span><span class="p">[</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">edge_timer</span><span class="p">[</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                            <span class="n">time_idx</span> <span class="o">=</span> <span class="n">t</span><span class="o">+</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
                            <span class="k">assert</span> <span class="n">time_idx</span> <span class="o">&lt;</span> <span class="n">sim_time</span>
                            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">agent_positions</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">eval_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">agent_positions</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="n">available</span><span class="p">[</span><span class="n">itr</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">eval_edge</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>

    <span class="c1"># Update edge timer at last timestep</span>
    <span class="n">transit_times</span><span class="p">[</span><span class="n">sim_time</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_timer</span>

    <span class="c1">#Catch agents that stay at states for multiple time steps</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">sim_time</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_agents</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">transit_times</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">agent_positions</span><span class="p">,</span><span class="n">caps</span><span class="p">,</span><span class="n">num_agents</span><span class="p">,</span><span class="n">transit_times</span><span class="p">,</span><span class="n">agent_caps</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Get agent capabilities</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="get_agent_capabilities"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.get_agent_capabilities">[docs]</a><span class="k">def</span> <span class="nf">get_agent_capabilities</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a list of agent capabilities. </span>
<span class="sd">    </span>
<span class="sd">    The order of capabilities in the list corresponds to the columns in </span>
<span class="sd">    agent_positions, but does **not** correspond to the agent order in the</span>
<span class="sd">    casefile agent list.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">capabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">agent_capabilities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_capabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">capabilities</span><span class="p">))</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">init_states</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#Count agents and capabilities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">capabilities</span><span class="p">:</span>
        <span class="n">choice_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">states</span><span class="p">[</span><span class="n">states</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
        <span class="n">num_capabilities</span><span class="p">[</span><span class="n">counts</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">init_states</span><span class="p">[</span><span class="n">choice_vals</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_capabilities</span><span class="p">[</span><span class="n">counts</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
            <span class="n">agent_capabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">agent_capabilities</span><span class="p">,</span> <span class="n">num_capabilities</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Get a consistent mapping from agent index to trajectory</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="get_agent_map"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.get_agent_map">[docs]</a><span class="k">def</span> <span class="nf">get_agent_map</span><span class="p">(</span><span class="n">agents</span><span class="p">,</span> <span class="n">agent_positions</span><span class="p">,</span> <span class="n">agent_caps</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
    <span class="c1"># Input:</span>
    <span class="c1"># list of agents</span>
    <span class="c1"># agent_positions and agent_caps from assign_caps_to_trajs</span>
    <span class="c1"># classes from compute_agent_classes</span>

    <span class="c1"># Output: a  dictionary mapping agents to trajectories</span>

    <span class="c1"># list of agents that haven&#39;t been assigned yet</span>
    <span class="n">unmapped_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">agents</span><span class="p">))]</span>
    <span class="c1"># build list of agent init_states and caps</span>
    <span class="n">init_states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">ag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">agents</span><span class="p">]</span>
    <span class="n">ag_caps</span> <span class="o">=</span> <span class="p">[</span><span class="n">classes</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">ag</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">agents</span><span class="p">]</span>

    <span class="n">ag_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># for each agent, give them an index in agent_positions (and thereby agent_caps)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">agents</span><span class="p">)):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ag_caps</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">init_states</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">ag_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">unmapped_idx</span> <span class="k">if</span> <span class="n">agent_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">==</span><span class="n">s</span> <span class="ow">and</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">==</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">unmapped_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ag_idx</span><span class="p">)</span>
        <span class="n">ag_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ag_idx</span>

    <span class="c1"># return map of agent to index in agent_positions</span>
    <span class="k">return</span> <span class="n">ag_dict</span></div>

<span class="c1">###############################################################################</span>
<span class="c1">#Determine Which Agents to Drop Out From Request</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="which_agent_down"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.which_agent_down">[docs]</a><span class="k">def</span> <span class="nf">which_agent_down</span><span class="p">(</span><span class="n">the_plan</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">agent_caps</span><span class="p">,</span><span class="n">where</span><span class="p">,</span><span class="n">quant</span><span class="p">,</span><span class="n">cap</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">step_time</span><span class="p">,</span><span class="n">world_max</span><span class="p">):</span>
    <span class="c1">#need to determine dropout agents given cap,qant,time,where</span>
    <span class="c1">#dropout_agents is [#,#,#] with # as agent index</span>
    <span class="n">dropout_agents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">agent_caps</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cap</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">test_points</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">time</span><span class="p">:</span><span class="n">time</span><span class="o">+</span><span class="n">step_time</span><span class="p">]:</span> 
                <span class="c1">#print(test_points)              </span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">test_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">world_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">test_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">where</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>
                <span class="c1">#print(ts.g.node[where][&#39;shape&#39;])</span>
                <span class="c1">#print(polygon.contains(point))</span>
                <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dropout_agents</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">quant</span><span class="p">:</span>
                        <span class="n">dropout_agents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                        <span class="k">break</span>  
    <span class="k">return</span> <span class="n">dropout_agents</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Generate Region Bound Definitions</span>
<span class="c1">#We also determine overlapping regions here</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="define_region_bounds"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.define_region_bounds">[docs]</a><span class="k">def</span> <span class="nf">define_region_bounds</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
    
    <span class="n">region_bounds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">box_bounds_obstacleList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">overlapping_regions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
        <span class="n">overlapping_regions</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="c1">#print(state)</span>
        <span class="n">state_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)])</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_points</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x_min</span><span class="p">:</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_max</span><span class="p">:</span>
                <span class="n">x_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y_min</span><span class="p">:</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y_max</span><span class="p">:</span>
                <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dia_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dia_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cent_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">x_min</span><span class="p">,</span><span class="n">x_max</span><span class="p">])</span>
        <span class="n">cent_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">y_min</span><span class="p">,</span><span class="n">y_max</span><span class="p">])</span>

        <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">dia_x</span><span class="p">,</span><span class="n">dia_y</span><span class="p">])</span>
        <span class="n">region_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">state_int</span><span class="p">,[</span><span class="n">cent_x</span><span class="p">,</span><span class="n">cent_y</span><span class="p">,</span><span class="n">diameter</span><span class="p">]])</span>
        <span class="n">box_bounds_obstacleList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">state_int</span><span class="p">,[</span><span class="n">x_min</span><span class="p">,</span><span class="n">x_max</span><span class="p">,</span><span class="n">y_min</span><span class="p">,</span><span class="n">y_max</span><span class="p">]])</span>

    <span class="k">for</span> <span class="n">region1</span> <span class="ow">in</span> <span class="n">box_bounds_obstacleList</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">region2</span> <span class="ow">in</span> <span class="n">box_bounds_obstacleList</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">region1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">region2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">x1_min</span> <span class="o">=</span> <span class="n">region1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x1_max</span> <span class="o">=</span> <span class="n">region1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">y1_min</span> <span class="o">=</span> <span class="n">region1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y1_max</span> <span class="o">=</span> <span class="n">region1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> 
                <span class="n">x2_min</span> <span class="o">=</span> <span class="n">region2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x2_max</span> <span class="o">=</span> <span class="n">region2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> 
                <span class="n">y2_min</span> <span class="o">=</span> <span class="n">region2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">y2_max</span> <span class="o">=</span> <span class="n">region2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">x1_min</span> <span class="o">&gt;=</span> <span class="n">x2_max</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x1_max</span> <span class="o">&lt;=</span> <span class="n">x2_min</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y1_max</span> <span class="o">&lt;=</span> <span class="n">y2_min</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y1_min</span> <span class="o">&gt;=</span> <span class="n">y2_max</span><span class="p">)):</span>
                    <span class="n">overlapping_regions</span><span class="p">[</span><span class="n">region1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">region_bounds</span><span class="p">,</span><span class="n">box_bounds_obstacleList</span><span class="p">,</span><span class="n">overlapping_regions</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#Generate Trajectories from a .sol file</span>
<span class="c1">###############################################################################</span>
<div class="viewcode-block" id="run_planner"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.run_planner">[docs]</a><span class="k">def</span> <span class="nf">run_planner</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">other_past_paths</span><span class="o">=</span><span class="p">[],</span> <span class="n">show_sol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1">#get all the environment variables from m</span>
    <span class="n">plot_region_bounds</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_region_bounds</span>
    <span class="n">obstaclesList</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">local_obstacles</span>
    <span class="n">max_attempts</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">max_attempts</span>
    <span class="n">max_rrt_time</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">max_rrt_time</span>
    <span class="n">agent_radius</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">agent_radius</span>
    <span class="n">planning_step_time</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">planning_step_time</span>
    <span class="n">cap_height_map</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">cap_height_map</span>
    <span class="n">record_sol</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">record_sol</span>
    <span class="k">if</span> <span class="n">show_sol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">show_sol</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">show_sol</span>
    <span class="n">grave_state</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">grave_state</span>
    
    
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">assert</span> <span class="s1">&#39;grave&#39;</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;prop&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>

    <span class="c1">#Take the data and parse it into state and edge transitions</span>
    <span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">end_time</span><span class="p">,</span><span class="n">preds</span> <span class="o">=</span> <span class="n">read_sol_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">sim_time</span> <span class="o">=</span> <span class="n">end_time</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time_vals&#39;</span><span class="p">,</span><span class="n">sim_time</span><span class="p">,</span> <span class="n">planning_step_time</span><span class="p">)</span>

    <span class="c1">###############################################################################</span>
    <span class="c1">#Generate individual region level trajectories</span>
    <span class="c1">###############################################################################</span>
    <span class="n">agent_positions</span><span class="p">,</span><span class="n">caps</span><span class="p">,</span><span class="n">num_agents</span><span class="p">,</span><span class="n">transit_times</span><span class="p">,</span><span class="n">agent_caps</span> <span class="o">=</span> <span class="n">assign_caps_to_trajs</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">preds</span><span class="p">,</span><span class="n">sim_time</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ReducedTs</span><span class="p">):</span>
        <span class="c1"># this TS has been reduced (some states removed)</span>
        <span class="c1"># need to update the agent positions by reinserting states/edges</span>
        <span class="c1"># and then use the original TS</span>
        <span class="n">expand_agent_positions</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">agent_positions</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">orig_ts</span>
    
    <span class="c1">###############################################################################</span>
    <span class="c1">#Generate Region Bound Definitions</span>
    <span class="c1">###############################################################################</span>
    <span class="n">region_bounds</span><span class="p">,</span><span class="n">box_bounds_obstacleList</span><span class="p">,</span><span class="n">overlapping_regions</span> <span class="o">=</span> <span class="n">define_region_bounds</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">states</span><span class="p">)</span>
   

    <span class="c1">###############################################################################</span>
    <span class="c1">#Obstacles and capability differentiation</span>
    <span class="c1">###############################################################################</span>
    <span class="c1">#Include any unforseen or hard coded obstacles or force agents to be on different planes of operation</span>
    <span class="c1">#cap_height_map = np.array([1,0,0,0,0,0,0,2,2,2])</span>
   
    <span class="c1">#obstaclesList  = [[</span>
    <span class="c1">#    [0,0,0],</span>
    <span class="c1">#    [0,0,0]</span>
    <span class="c1">#],</span>
    <span class="c1">#[</span>
    <span class="c1">#    [0,0,0],</span>
    <span class="c1">#    [0,0,0]</span>
    <span class="c1">#],</span>
    <span class="c1">#[</span>
    <span class="c1">#    [0,0,0],</span>
    <span class="c1">#    [0,0,0]</span>
    <span class="c1">#]</span>
    <span class="c1">#]</span>
    
    <span class="c1">###############################################################################</span>
    <span class="c1">#Generate low level trajectories</span>
    <span class="c1">###############################################################################</span>
    <span class="c1">#I do this sequentally so it is less book keeping. It shouldnt really matter</span>
    <span class="c1">#since the paths are computed sequentally in rrt anyway.</span>

    <span class="c1">#agent_radius = [6,4,4,4,4,4,4,2,2,2]</span>
    <span class="c1">#agent_radius = np.multiply(np.ones(10),2)</span>

    <span class="c1">#planning_step_time = 10</span>
    <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">restart_main_loop</span> <span class="o">=</span><span class="kc">False</span>
    <span class="c1">#Main Loop Begins Here:</span>
    <span class="k">while</span> <span class="n">found_the_plan</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">restart_main_loop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">the_plan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_agents</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">sim_time</span><span class="p">))),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">past_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">past_a</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_agents</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">restart_main_loop</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;found: &#39;</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="c1">#print(a)</span>
        <span class="c1">################################################################################</span>
        <span class="c1">#Determine which past paths to consider given agent capabilities (flying or not)</span>
        <span class="c1">################################################################################</span>
            <span class="n">past_path_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cap_height_map</span> <span class="o">==</span> <span class="n">cap_height_map</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">to_avoid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">past_path_idxs</span><span class="p">,</span><span class="n">past_a</span><span class="p">)</span>
            
            <span class="n">cap_past_paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#if other_past_paths == []: </span>
            <span class="c1">#    if len(to_avoid) != 0:</span>
            <span class="c1">#        for num in range(0,len(to_avoid)):</span>
            <span class="c1">#            index = np.where(past_a == to_avoid[num])</span>
            <span class="c1">#            cap_past_paths.append(past_paths[index[0][0]])</span>
            <span class="c1">#    else:</span>
            <span class="c1">#        cap_past_paths = None</span>
            
            
            
        <span class="c1">####################### MAY NEED TO REMOVE THIS ################################</span>
        <span class="c1">#THIS MAKES ALL AGENTS INTO LARGE OBSTACLES FOR EXPERIMENT#</span>
            <span class="c1">#else: </span>
            <span class="c1">#    cap_past_paths.append(past_paths)</span>
            <span class="c1">#print(&#39;other_shape: &#39;,np.shape(other_past_paths),&#39;orig_shape &#39;,np.shape(past_paths))</span>
            <span class="k">for</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">other_past_paths</span><span class="p">:</span> 
                <span class="n">cap_past_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">past_paths</span><span class="p">:</span>
                <span class="n">cap_past_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="n">obstacles</span> <span class="o">=</span> <span class="n">obstaclesList</span><span class="p">[</span><span class="n">cap_height_map</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>    
            <span class="c1">#print(np.shape(cap_past_paths))</span>
        <span class="c1">################################################################################</span>
        <span class="c1">#Cycle through actions for agent</span>
        <span class="c1">################################################################################</span>

            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">sim_time</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">restart_main_loop</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
                <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">time_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
                    <span class="c1">#if a == 6:</span>
                    <span class="c1">#    print(agent_positions[:,6],action,t,time_idx)</span>
                    <span class="k">if</span> <span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">start_point</span> <span class="o">=</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>


                    <span class="c1">##Find Random Start Positions:</span>
        <span class="c1">###############################################################################</span>
        <span class="c1">#Determine start positions</span>
        <span class="c1">###############################################################################</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">grave_state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">action</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">start_point</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">collision</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">planning_step_time</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">collision_check</span><span class="p">(</span><span class="n">start_point</span><span class="p">,</span><span class="n">time_idx</span><span class="o">+</span><span class="n">inc</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">cap_past_paths</span><span class="p">)):</span>
                                        <span class="n">collision</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">count_idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                            <span class="n">other_box_regions</span> <span class="o">=</span> <span class="n">single_region_box_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">box_bounds_obstacleList</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span><span class="o">=</span><span class="n">time_idx</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                        <span class="k">else</span><span class="p">:</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                            <span class="n">other_box_regions</span> <span class="o">=</span> <span class="n">single_region_box_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">box_bounds_obstacleList</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>

                                <span class="k">if</span> <span class="n">cap_past_paths</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                                    <span class="n">timed_past_paths</span> <span class="o">=</span> <span class="p">[]</span>
                                    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cap_past_paths</span><span class="p">)):</span>
                                        <span class="n">timed_past_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cap_past_paths</span><span class="p">[</span><span class="n">w</span><span class="p">][(</span><span class="n">time_idx</span><span class="p">):])</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">timed_past_paths</span> <span class="o">=</span> <span class="kc">None</span>

                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">other_regions</span><span class="p">,</span><span class="n">obstacles</span><span class="p">))</span>
                                <span class="n">no_short_path</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">collision_idx</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="k">while</span> <span class="n">no_short_path</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                                    <span class="n">candidate_path</span> <span class="o">=</span> <span class="n">RRT_Get_Path</span><span class="p">(</span><span class="n">regions_to_avoid</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="n">start_point</span><span class="p">,</span><span class="n">goal</span><span class="o">=</span><span class="n">rand_point</span><span class="p">,</span><span class="n">past_paths</span><span class="o">=</span><span class="n">timed_past_paths</span><span class="p">,</span><span class="n">start_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">goal_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">agentnum</span><span class="o">=</span><span class="n">a</span><span class="p">,</span><span class="n">agent_radius</span><span class="o">=</span><span class="n">agent_radius</span><span class="p">,</span><span class="n">expandDis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">,</span><span class="n">max_rrt_time</span><span class="o">=</span><span class="n">max_rrt_time</span><span class="p">,</span><span class="n">box_bounds_obs_regions</span><span class="o">=</span><span class="n">other_box_regions</span><span class="p">)</span>

                                    <span class="n">len_cand_path</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_path</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">len_cand_path</span> <span class="o">&gt;</span> <span class="n">planning_step_time</span> <span class="ow">or</span> <span class="n">len_cand_path</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">collision_idx</span> <span class="o">+=</span><span class="mi">1</span>
                                        <span class="k">if</span> <span class="n">collision_idx</span> <span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
                                            <span class="n">restart_main_loop</span> <span class="o">=</span> <span class="kc">True</span>
                                            <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
                                            <span class="k">break</span>
                                        <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">:</span>
                                                <span class="k">if</span> <span class="n">count_idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                    <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span><span class="o">=</span><span class="n">time_idx</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                                <span class="k">else</span><span class="p">:</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                    <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>

                                    <span class="k">elif</span> <span class="n">len_cand_path</span> <span class="o">==</span> <span class="n">planning_step_time</span><span class="p">:</span>
                                        <span class="n">no_short_path</span> <span class="o">=</span> <span class="kc">False</span>
                                        <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="p">:</span><span class="n">time_idx</span><span class="o">+</span><span class="n">planning_step_time</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_path</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">diff_len</span> <span class="o">=</span> <span class="n">planning_step_time</span><span class="o">-</span><span class="n">len_cand_path</span>
                                        <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="p">:</span><span class="n">time_idx</span><span class="o">+</span><span class="n">len_cand_path</span><span class="p">]</span><span class="o">=</span><span class="n">candidate_path</span>
                                        <span class="k">for</span> <span class="n">dif_inc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">diff_len</span><span class="p">):</span>
                                            <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">+</span><span class="n">len_cand_path</span><span class="o">+</span><span class="n">dif_inc</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_path</span><span class="p">[</span><span class="n">len_cand_path</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                        <span class="n">no_short_path</span> <span class="o">=</span> <span class="kc">False</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">planning_step_time</span><span class="p">):</span>
                                    <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">+</span><span class="n">inc</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_point</span>
                                <span class="c1">#Check if this point is in any new past paths</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">count_idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                        <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span><span class="o">=</span><span class="n">time_idx</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">,</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                        <span class="c1">#print other_regions</span>
                                        <span class="c1">#print obstacles</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                        <span class="n">rand_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">planning_step_time</span><span class="p">):</span>
                                <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">+</span><span class="n">inc</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand_point</span>
        <span class="c1">#If agent needs to transistion, this determines start and end points</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">grave_state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">action</span><span class="p">]):</span>
                        <span class="c1">#transition</span>
                        <span class="k">if</span> <span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                <span class="n">start_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">start_region</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                        <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">count_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                            <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span><span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span><span class="n">time_idx</span><span class="o">+</span><span class="p">((</span><span class="n">action</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">),</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                                <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                        <span class="n">start_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span> <span class="n">time_idx</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                        <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                        <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">count_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                            <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span> <span class="n">time_idx</span><span class="o">+</span><span class="p">((</span><span class="n">action</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">),</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                    <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                    <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">over_inc</span><span class="o">=</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                        <span class="n">regions_to_avoid</span> <span class="o">=</span> <span class="n">split_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                        <span class="n">box_regions_to_avoid</span> <span class="o">=</span> <span class="n">split_box_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">box_bounds_obstacleList</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                        <span class="c1">#print &#39;obstacles: &#39;,obstacles</span>
                        <span class="c1">#print &#39;regions_to_avoid: &#39;,regions_to_avoid</span>
                        <span class="c1">#print &#39;action: &#39;, action</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions_to_avoid</span><span class="p">):</span>
                            <span class="n">regions_to_avoid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">regions_to_avoid</span><span class="p">))</span>

                        <span class="k">if</span> <span class="n">cap_past_paths</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
                            <span class="n">timed_past_paths</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cap_past_paths</span><span class="p">)):</span>
                                <span class="n">timed_past_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cap_past_paths</span><span class="p">[</span><span class="n">w</span><span class="p">][(</span><span class="n">time_idx</span><span class="p">):])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">timed_past_paths</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1">################################################################################</span>
        <span class="c1">#Compute RRT path</span>
        <span class="c1">################################################################################</span>

                        <span class="n">no_viable_path</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">loop_idx</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">while</span> <span class="n">no_viable_path</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                            <span class="n">loop_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">loop_idx</span> <span class="o">&gt;</span> <span class="n">max_attempts</span><span class="p">:</span>
                                <span class="n">restart_main_loop</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">break</span>
                            <span class="k">if</span> <span class="n">count_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#regions_to_avoid=regions_to_avoid</span>
                                <span class="n">candidate_path</span> <span class="o">=</span> <span class="n">RRT_Get_Path</span><span class="p">(</span><span class="n">regions_to_avoid</span><span class="o">=</span><span class="n">regions_to_avoid</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="n">start_point</span><span class="p">,</span><span class="n">goal</span><span class="o">=</span><span class="n">goal_point</span><span class="p">,</span><span class="n">past_paths</span><span class="o">=</span><span class="n">timed_past_paths</span><span class="p">,</span><span class="n">start_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">goal_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">agentnum</span><span class="o">=</span><span class="n">a</span><span class="p">,</span><span class="n">agent_radius</span><span class="o">=</span><span class="n">agent_radius</span><span class="p">,</span><span class="n">expandDis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">,</span><span class="n">max_rrt_time</span><span class="o">=</span><span class="n">max_rrt_time</span><span class="p">,</span><span class="n">box_bounds_obs_regions</span><span class="o">=</span><span class="n">box_regions_to_avoid</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">candidate_path</span> <span class="o">=</span> <span class="n">RRT_Get_Path</span><span class="p">(</span><span class="n">regions_to_avoid</span><span class="o">=</span><span class="n">regions_to_avoid</span><span class="p">,</span><span class="n">start</span><span class="o">=</span><span class="n">start_point</span><span class="p">,</span><span class="n">goal</span><span class="o">=</span><span class="n">goal_point</span><span class="p">,</span><span class="n">start_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">goal_region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">agentnum</span><span class="o">=</span><span class="n">a</span><span class="p">,</span><span class="n">agent_radius</span><span class="o">=</span><span class="n">agent_radius</span><span class="p">,</span><span class="n">expandDis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">,</span><span class="n">max_rrt_time</span><span class="o">=</span><span class="n">max_rrt_time</span><span class="p">,</span><span class="n">box_bounds_obs_regions</span><span class="o">=</span><span class="n">box_regions_to_avoid</span><span class="p">)</span>
                            <span class="n">len_cand_path</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_path</span><span class="p">)</span>
                            <span class="n">plan_time_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">planning_step_time</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">len_cand_path</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                                        <span class="n">start_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                        <span class="n">start_region</span> <span class="o">=</span> <span class="kc">None</span>
                                        <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                                <span class="k">if</span> <span class="n">count_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                    <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                    <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span><span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span><span class="n">t</span><span class="o">+</span><span class="p">((</span><span class="n">action</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">),</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                                        <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                <span class="n">start_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                                <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                                <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                                <span class="k">if</span> <span class="n">count_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                                    <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">current_time</span> <span class="o">=</span> <span class="n">t</span><span class="o">+</span><span class="p">((</span><span class="n">action</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">),</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">start_point</span> <span class="o">=</span> <span class="kc">None</span>
                                    <span class="k">for</span> <span class="n">region</span><span class="p">,</span><span class="nb">set</span> <span class="ow">in</span> <span class="n">region_bounds</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                            <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">single_region_bounds_for_rrt</span><span class="p">(</span><span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">region_bounds</span><span class="p">,</span><span class="n">overlapping_regions</span><span class="p">)</span>
                                            <span class="n">other_regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">obstacles</span><span class="p">,</span><span class="n">other_regions</span><span class="p">))</span>
                                            <span class="n">goal_point</span> <span class="o">=</span> <span class="n">random_point_in_region</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span><span class="n">agent_radius</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">past_paths</span> <span class="o">=</span> <span class="n">cap_past_paths</span><span class="p">,</span><span class="n">other_obstacles</span><span class="o">=</span><span class="n">other_regions</span><span class="p">,</span><span class="n">plot_region_bounds</span><span class="o">=</span><span class="n">plot_region_bounds</span><span class="p">)</span>

                            <span class="k">elif</span> <span class="n">len_cand_path</span> <span class="o">&lt;=</span> <span class="n">plan_time_bound</span><span class="p">:</span>
                                <span class="c1">#put in loop to make extra hold points, and then slap that on the path and add it to the_plan</span>
                                <span class="n">temp_hold</span> <span class="o">=</span> <span class="p">[]</span>
                                <span class="n">extra_hold</span> <span class="o">=</span> <span class="n">plan_time_bound</span> <span class="o">-</span> <span class="n">len_cand_path</span>
                                <span class="n">hold_point</span> <span class="o">=</span> <span class="n">candidate_path</span><span class="p">[</span><span class="n">len_cand_path</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">extra</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">extra_hold</span><span class="p">):</span>
                                    <span class="n">temp_hold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hold_point</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">temp_hold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">candidate_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">candidate_path</span><span class="p">,</span><span class="n">temp_hold</span><span class="p">))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">candidate_path</span> <span class="o">=</span> <span class="n">candidate_path</span>
                                <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">plan_time_bound</span><span class="p">):</span>
                                    <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">time_idx</span><span class="o">+</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_path</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>

                                <span class="n">no_viable_path</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="n">len_cand_path</span><span class="p">,</span><span class="n">plan_time_bound</span><span class="p">)</span>
                                <span class="n">no_viable_path</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">grave_state</span> <span class="ow">in</span> <span class="p">[</span><span class="n">action</span><span class="p">]):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;its dead&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">iters</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">sim_time</span><span class="o">*</span><span class="n">planning_step_time</span><span class="p">):</span>
                            <span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">iters</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">])</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unexpected Trajectory Sequence - Edges should be [start,end,time]&#39;</span><span class="p">)</span>
            <span class="c1">#print(restart_main_loop,found_the_plan)</span>
            <span class="k">if</span> <span class="n">restart_main_loop</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_the_plan</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">count_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">past_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="c1">#if a == 6:</span>
                    <span class="c1">#    print(the_plan[a],action,t,time_idx)</span>
            <span class="n">past_formatted</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#print(the_plan[a])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">planning_step_time</span><span class="p">,</span><span class="n">sim_time</span><span class="p">)):</span>
                <span class="n">past_formatted</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">the_plan</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>

            <span class="n">past_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">past_formatted</span><span class="p">)</span>


    <span class="n">the_plan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">the_plan</span><span class="p">)</span>

    <span class="c1"># Draw final path</span>


        <span class="c1">#plt.plot([x for (x, y) in smoothedPath], [</span>
        <span class="c1">#    y for (x, y) in smoothedPath], &#39;-b&#39;)</span>
        <span class="c1">#plt.plot(start[i][0], start[i][1], &quot;or&quot;)</span>
        <span class="c1">#plt.plot(goal[i][0], goal[i][1], &quot;xr&quot;)</span>
    <span class="c1">#plt.xlim(plot_bounds[0],plot_bounds[1])</span>
    <span class="c1">#plt.ylim(plot_bounds[2],plot_bounds[3])</span>
    <span class="c1">#plt.axis(plot_bounds)</span>
    <span class="c1">#plt.grid(True)</span>
    <span class="c1">#for (x, y, size) in obstacleList:</span>
    <span class="c1">#    PlotCircle(x, y, size,plot_bounds)</span>
    <span class="c1">#plt.pause(0.01)</span>
    <span class="c1">#plt.grid(True)</span>
    <span class="c1">#plt.pause(0.01)  # Need for Mac</span>
    <span class="c1">#plt.show()</span>


    <span class="c1">#new_bounds = split_bounds_for_rrt(0,1,region_bounds)</span>

    <span class="c1">#RRT_Get_Path(new_bounds,start=[(5,5)],goal=[(5,50)])</span>


    <span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;runtime:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span>
    <span class="n">runtime</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span>

    <span class="k">if</span> <span class="n">show_sol</span><span class="p">:</span>
        <span class="c1">###############################################################################</span>
        <span class="c1">#Print the Final Trajectories</span>
        <span class="n">caps_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">agent_caps</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">viewport</span> <span class="o">=</span> <span class="n">show_world</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_agents</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">caps_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;-k&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">caps_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;:k&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">caps_idxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;--g&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">caps_idxs</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;-.r&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">agent_caps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">caps_idxs</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">the_plan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;-.b&#39;</span><span class="p">)</span>


        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="n">plot_region_bounds</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">waitforbuttonpress</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>

        <span class="c1">###############################################################################</span>
        <span class="c1">#Play a video of the Trajectories</span>
    <span class="c1"># if record_sol:</span>
    <span class="c1">#     metadata = dict(title=&#39;Traj_Sol&#39;, artist=&#39;Matplotlib&#39;,comment=&#39;Movie support!&#39;)</span>
    <span class="c1">#     writer = FFMpegWriter(fps=12, metadata=metadata)</span>
    <span class="c1">#     writer.setup(fig,&#39;pre_replan_robust.mp4&#39;,1000)</span>

    <span class="c1">#     for time in range(0,(sim_time)):</span>
    <span class="c1">#         plt.clf()</span>
    <span class="c1">#         fig,viewport = show_world(ts,fig)</span>
    <span class="c1">#         for i in range(0,num_agents):</span>
    <span class="c1">#             if agent_caps[i] == 1:</span>
    <span class="c1">#                 plt.plot(the_plan[i][time][0], the_plan[i][time][1],color=&quot;r&quot;,marker=&#39;x&#39;,markersize=15)</span>
    <span class="c1">#             elif agent_caps[i] == 2:</span>
    <span class="c1">#                 plt.plot(the_plan[i][time][0], the_plan[i][time][1],&quot;oc&quot;,markersize=15)</span>
    <span class="c1">#             elif agent_caps[i] == 3:</span>
    <span class="c1">#                 plt.plot(the_plan[i][time][0], the_plan[i][time][1],&quot;*w&quot;,markersize=15)</span>
    <span class="c1">#             elif agent_caps[i] == 8:</span>
    <span class="c1">#                 plt.plot(the_plan[i][time][0], the_plan[i][time][1],&quot;hk&quot;,markersize=12)</span>


    <span class="c1">#         plt.axis(plot_region_bounds)</span>
    <span class="c1">#         plt.title(&#39;Time: &#39; + str(np.divide(time,10)))</span>
    <span class="c1">#         writer.grab_frame()</span>
    <span class="c1">#         plt.show(block=False)</span>
    <span class="c1">#         plt.pause(0.01)</span>


    <span class="k">return</span><span class="p">(</span><span class="n">the_plan</span><span class="p">,</span><span class="n">agent_caps</span><span class="p">,</span><span class="n">past_paths</span><span class="p">)</span></div>
    
    
    

    
    
    
    
    
<div class="viewcode-block" id="run_planner_cpp"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.run_planner_cpp">[docs]</a><span class="k">def</span> <span class="nf">run_planner_cpp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">ts</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1">#get all the environment variables from m</span>
    <span class="n">plot_region_bounds</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_region_bounds</span>
    <span class="n">obstaclesList</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">local_obstacles</span>
    <span class="n">max_attempts</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">max_attempts</span>
    <span class="n">max_rrt_time</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">max_rrt_time</span>
    <span class="n">agent_radius</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">agent_radius</span>
    <span class="n">planning_step_time</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">planning_step_time</span>
    <span class="n">cap_height_map</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">cap_height_map</span>
    <span class="n">record_sol</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">record_sol</span>
    <span class="n">show_sol</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">show_sol</span>
    <span class="n">grave_state</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">grave_state</span>
    
    
    <span class="c1"># for u, v in ts.g.edges():</span>
        <span class="c1"># assert &#39;grave&#39; in ts.g.node[v][&#39;prop&#39;] or ts.g.has_edge(v,u)</span>

    <span class="c1">#Take the data and parse it into state and edge transitions</span>
    <span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">end_time</span><span class="p">,</span><span class="n">preds</span> <span class="o">=</span> <span class="n">read_sol_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">sim_time</span> <span class="o">=</span> <span class="n">end_time</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time_vals&#39;</span><span class="p">,</span><span class="n">sim_time</span><span class="p">,</span> <span class="n">planning_step_time</span><span class="p">)</span>

    <span class="c1">###############################################################################</span>
    <span class="c1">#Generate individual region level trajectories</span>
    <span class="c1">###############################################################################</span>
    <span class="n">agent_positions</span><span class="p">,</span><span class="n">caps</span><span class="p">,</span><span class="n">num_agents</span><span class="p">,</span><span class="n">transit_times</span><span class="p">,</span><span class="n">agent_caps</span> <span class="o">=</span> <span class="n">assign_caps_to_trajs</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">preds</span><span class="p">,</span><span class="n">sim_time</span><span class="p">)</span>

    <span class="c1"># Get the dictionary mapping casefile agent indices to columns in agent_positions matrix.</span>
    <span class="n">agent_capabilities</span> <span class="o">=</span> <span class="n">get_agent_capabilities</span><span class="p">(</span><span class="n">states</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">agent_classes</span> <span class="o">=</span> <span class="n">compute_agent_classes</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">agents</span><span class="p">,</span> <span class="n">compute_capability_bitmap</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">agents</span><span class="p">))</span>
    <span class="n">agent_index_dict</span> <span class="o">=</span> <span class="n">get_agent_map</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">agents</span><span class="p">,</span> <span class="n">agent_positions</span><span class="p">,</span> <span class="n">agent_capabilities</span><span class="p">,</span> <span class="n">agent_classes</span><span class="p">)</span>


    <span class="c1"># TODO: Change to use actually useful task function instead of create_random_tasks()</span>
    <span class="n">agent_tasks</span> <span class="o">=</span> <span class="n">create_random_tasks</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">,</span> <span class="n">agent_index_dict</span><span class="p">)</span>
    <span class="n">output_strings</span> <span class="o">=</span> <span class="n">agent_positions_to_MOOS_strings</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">,</span> <span class="n">agent_index_dict</span><span class="p">,</span> <span class="n">agent_tasks</span><span class="o">=</span><span class="n">agent_tasks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">agent_positions</span><span class="p">,</span> <span class="n">output_strings</span><span class="p">,</span> <span class="n">agent_tasks</span><span class="p">,</span> <span class="n">agent_index_dict</span></div>




<div class="viewcode-block" id="agent_positions_to_MOOS_strings"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.agent_positions_to_MOOS_strings">[docs]</a><span class="k">def</span> <span class="nf">agent_positions_to_MOOS_strings</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">,</span> <span class="n">num_agents</span><span class="p">,</span> <span class="n">agent_index_dict</span><span class="p">,</span> <span class="n">agent_tasks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Parses agent positions and tasks into string form to send to MOOS.</span>

<span class="sd">    The final format of the output strings is &quot;state1-state1:start_time-end_time:task1; state1-state2:start_time:end_time:None; ...&quot;</span>

<span class="sd">    The task &quot;None&quot; specifies that the agent does not have a task. Note that all agents have the task &quot;None&quot; when</span>
<span class="sd">    traversing edges between states.</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_positions (list): A list of lists containing the positions of each agent at each time step. The first</span>
<span class="sd">            index corresponds to time step, and the second index corresponds to agent number. For example,</span>
<span class="sd">            ``agent_positions[ii][jj]`` is the position of the jjth agent at time step ii. If agent jj is in a state</span>
<span class="sd">            at time ii, then ``agent_positions[ii][jj]`` is an integer corresponding to the state (e.g. 7 for state </span>
<span class="sd">            Q7). If agent jj is traversing an edge between states at time ii, then ``agent_positions[ii][jj]`` is</span>
<span class="sd">            a list with entries ``[state1, state2, time_duration]`` meaning it has ``time_duration`` steps to transfer</span>
<span class="sd">            from ``state1`` to ``state2``.</span>
<span class="sd">        num_agents (int): Number of agents in the network. TODO: This is redundant; we can compute this from</span>
<span class="sd">            agent_positions itself.</span>
<span class="sd">        agent_index_dict (dict): A dictionary mapping agent number to column index (second dimension index) in</span>
<span class="sd">            agent_positions. The ordering of agent numbers does **not** correspond to the column order; i.e.</span>
<span class="sd">            the iith agent does not correspond to the iith column in ``agent_positions``. Instead, it corresponds</span>
<span class="sd">            to the ``agent_index_dict[ii]`` index in ``agent_positions``.</span>
<span class="sd">        agent_tasks (list): A list of lists similar to agent_positions, but containing the task that each agent</span>
<span class="sd">            is doing at each time step. **Work in progress; final format TBA.**</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list): A list of strings with the format specified previously.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Parses agent_positions into string form to send to MOOS.</span>
    <span class="c1"># Format of the strings is:</span>
    <span class="c1">#   state1:start_time-end_time; state1-state2:start_time-end_time; state2:start_time-end_time...</span>

    <span class="n">max_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">)</span>
    <span class="n">output_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_agents</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">agent_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_agents</span><span class="p">):</span>
        <span class="n">agent_column_number</span> <span class="o">=</span> <span class="n">agent_index_dict</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="c1"># The column number of agent_positions corresponding to agent kk</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">agent_tasks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">agent_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>

        <span class="c1"># Get rid of obnoxious Numpy integer types</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># First row of agent_positions corresponds to time step 0 when start_time = 0</span>
        <span class="c1"># TODO: Pass in start_time as a function argument?</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="mi">0</span> 

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_steps</span><span class="p">):</span>
            <span class="n">next_location</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">agent_tasks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">next_task</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_task</span> <span class="o">=</span> <span class="n">agent_tasks</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>

            <span class="c1"># Get rid of Numpy integer types</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">next_location</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_location</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="n">next_location</span> <span class="o">==</span> <span class="n">location</span> <span class="ow">and</span> <span class="n">task</span> <span class="o">==</span> <span class="n">next_task</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">max_steps</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># End of the array; save the data</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">+</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 is for convention, even though this will make end_time = max_steps+1</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_location</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>

                    <span class="c1"># Add the task</span>
                    <span class="k">if</span> <span class="n">next_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="s1">&#39;NULL&#39;</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">agent_tasks</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Since either the location has changed or the task has changed, end the current schedule chunk and begin the next one.</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">+</span> <span class="n">counter</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># Location is an edge. Members of the list are [start_location, end_location, max_traversal_time]</span>
                    <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>

                <span class="c1"># Add the task</span>
                <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="s1">&#39;NULL&#39;</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">task</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
                
                <span class="n">location</span> <span class="o">=</span> <span class="n">next_location</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="n">end_time</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">next_task</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Corner case for last time step</span>
                <span class="c1"># Add next_location to the end of the string</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">max_steps</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">end_time</span> <span class="o">=</span> <span class="n">start_time</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># For sake of convention, we do this even though this will make end_time = max_time + 1</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_location</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_location</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_location</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-q&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_location</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
                    
                    <span class="c1"># Add the task</span>
                    <span class="k">if</span> <span class="n">next_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="s1">&#39;NULL&#39;</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_strings</span><span class="p">[</span><span class="n">agent_number</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">next_task</span> <span class="o">+</span> <span class="s1">&#39;; &#39;</span>


    <span class="k">return</span> <span class="n">output_strings</span></div>



    
    
<div class="viewcode-block" id="create_random_tasks"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.create_random_tasks">[docs]</a><span class="k">def</span> <span class="nf">create_random_tasks</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">,</span> <span class="n">agent_index_dict</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates random tasks for agents. Placeholder function.</span>

<span class="sd">    Task string options are:</span>

<span class="sd">        - NULL</span>
<span class="sd">        - LOITER</span>
<span class="sd">        - RASTER</span>
<span class="sd">        - DEFENSE</span>
<span class="sd">        - ESCORT</span>
<span class="sd">        - KILLCHAIN</span>
<span class="sd">        - BLOCKADE</span>

<span class="sd">    All agents have have the task &quot;NONE&quot; when they are traversing an edge</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_positions (list): A list of lists containing the positions of each agent at each time step. The first</span>
<span class="sd">            index corresponds to time step, and the second index corresponds to agent number. For example,</span>
<span class="sd">            ``agent_positions[ii][jj]`` is the position of the jjth agent at time step ii. If agent jj is in a state</span>
<span class="sd">            at time ii, then ``agent_positions[ii][jj]`` is an integer corresponding to the state (e.g. 7 for state </span>
<span class="sd">            Q7). If agent jj is traversing an edge between states at time ii, then ``agent_positions[ii][jj]`` is</span>
<span class="sd">            a list with entries ``[state1, state2, time_duration]`` meaning it has ``time_duration`` steps to transfer</span>
<span class="sd">            from ``state1`` to ``state2``.</span>
<span class="sd">        agent_index_dict (dict): A dictionary mapping agent number to column index in the ``agent_positions matrix``. The</span>
<span class="sd">            column in ``agent_positions`` corresponding to agent ii is given by ``agent_index_dict[ii]``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list): List of lists agent_tasks. The first dimension indexes time step,</span>
<span class="sd">        the second dimension indexes agent number. For example,</span>
<span class="sd">        agent_tasks[ii][jj] contains the task string for the jjth agent at time step ii</span>
<span class="sd">        (e.g. &quot;BLOCKADE&quot;).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># NOTE: The &#39;NULL&#39; / &#39;NONE&#39; task should always be first (index 0) to make renaming it</span>
    <span class="c1">#       easier.</span>
    <span class="n">task_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NULL&#39;</span><span class="p">,</span> <span class="s1">&#39;LOITER&#39;</span><span class="p">,</span> <span class="s1">&#39;RASTER&#39;</span><span class="p">,</span> <span class="s1">&#39;DEFENSE&#39;</span><span class="p">,</span> <span class="s1">&#39;ESCORT&#39;</span><span class="p">,</span> <span class="s1">&#39;KILLCHAIN&#39;</span><span class="p">,</span> <span class="s1">&#39;BLOCKADE&#39;</span><span class="p">]</span>
    <span class="n">num_tasks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">task_list</span><span class="p">)</span>

    <span class="n">num_agents</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">max_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">)</span>

    <span class="c1"># Preallocate the agent_tasks</span>
    <span class="n">agent_tasks</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">num_agents</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_agents</span><span class="p">):</span>
        <span class="n">agent_column_number</span> <span class="o">=</span> <span class="n">agent_index_dict</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>
        <span class="n">current_task</span> <span class="o">=</span> <span class="n">task_list</span><span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="n">num_tasks</span><span class="p">)]</span>
        <span class="n">agent_tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_task</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">max_steps</span><span class="p">):</span>
            <span class="n">next_location</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">next_location</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_location</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="n">next_location</span> <span class="o">==</span> <span class="n">location</span><span class="p">:</span>
                <span class="n">agent_tasks</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_task</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_location</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># Agent is traversing an edge.</span>
                    <span class="c1"># Task is always NONE when traversing an edge.</span>
                    <span class="n">current_task</span> <span class="o">=</span> <span class="n">task_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># NULL task</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_task</span> <span class="o">=</span> <span class="n">task_list</span><span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="n">num_tasks</span><span class="p">)]</span>

                <span class="n">agent_tasks</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">agent_column_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_task</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">next_location</span>

    <span class="k">return</span> <span class="n">agent_tasks</span></div>


<div class="viewcode-block" id="expand_agent_positions"><a class="viewcode-back" href="../../catl_planning.html#catl_planning.traj_planner.expand_agent_positions">[docs]</a><span class="k">def</span> <span class="nf">expand_agent_positions</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">agent_positions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Edits agent_positions in-place to reinsert removed states and edges.</span>
<span class="sd">    This is meant for use with reduce_ts in decomposition_functions.py, which</span>
<span class="sd">    removes unnecessary states and combines the edge weights.</span>

<span class="sd">    This function takes agent paths described by agent positions and replaces</span>
<span class="sd">    edges with the expanded path by reinserting removed states and edges.</span>

<span class="sd">    Example:</span>
<span class="sd">      q0 -weight:2-&gt; q1 -weight:4-&gt; q2</span>

<span class="sd">      q1 was removed by reduce_ts</span>

<span class="sd">      solution has q0-weight:6-&gt;q2</span>

<span class="sd">      this function edits the solution to go through q1 again</span>

<span class="sd">    Args:</span>
<span class="sd">        ts: the reduced TS</span>
<span class="sd">        agent_positions: a numpy array where each row is a time and each column is an agent</span>
<span class="sd">                         elements can be a state or an edge</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">orig_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">orig_ts</span>
    <span class="c1"># location_tracker: maps agent indices to a tuple (edge_num, time)</span>
    <span class="c1">#                   where edge_num is which collapsed edge it should be in</span>
    <span class="c1">#                   and time is how long it has been on that edge</span>
    <span class="n">location_tracker</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">agent_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">agent_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">agent_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">orig_ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">int2state</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> \
                                  <span class="n">int2state</span><span class="p">(</span><span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])):</span>
                <span class="c1"># this is either a state, or an edge that exists in the original graph</span>
                <span class="c1"># nothing to do but make sure location_tracker is reset</span>
                <span class="n">location_tracker</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startstate</span><span class="p">,</span> <span class="n">endstate</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">startstate</span><span class="p">,</span> <span class="n">endstate</span> <span class="o">=</span> <span class="n">int2state</span><span class="p">(</span><span class="n">startstate</span><span class="p">),</span> <span class="n">int2state</span><span class="p">(</span><span class="n">endstate</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">orig_ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">startstate</span><span class="p">,</span> <span class="n">endstate</span><span class="p">)</span>
 
                <span class="n">edge_num</span><span class="p">,</span> <span class="n">time_spent</span> <span class="o">=</span> <span class="n">location_tracker</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">collapsed_edges</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">startstate</span><span class="p">,</span> <span class="n">endstate</span><span class="p">)[</span><span class="s1">&#39;collapsed_edges&#39;</span><span class="p">]</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">collapsed_edges</span><span class="p">[</span><span class="n">edge_num</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">orig_ts</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># if this is the last collapsed edge, then the</span>
                <span class="c1"># final state should be the same as the endstate</span>
                <span class="k">assert</span> <span class="n">edge_num</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">collapsed_edges</span><span class="p">)</span> <span class="ow">or</span> \
                       <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">endstate</span>

                <span class="k">if</span> <span class="n">time_spent</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]:</span>
                    <span class="c1"># need to stay on this edge</span>
                    <span class="c1"># Note: converting from qi -&gt; i with int</span>
                    <span class="c1"># TODO create helper functions to convert from qi &lt;-&gt; i</span>
                    <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">state2int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">state2int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]]</span>
                    <span class="n">location_tracker</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_num</span><span class="p">,</span> <span class="n">time_spent</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># finished this edge</span>
                    <span class="c1"># need to stop at the end state of this collapsed edge</span>
                    <span class="n">agent_positions</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">state2int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># and move to next edge</span>
                    <span class="n">location_tracker</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_num</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 by the contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>